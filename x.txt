# Función para verificar si la base de datos está disponible
def esta_base_datos_disponible():
    """ Verificar si la base de datos está disponible """
    try:
        connections['default'].ensure_connection()
        return True
    except Exception:
        return False
@api_view(['POST'])
def guardar_datos_sensor(request):
    if request.method == 'POST':
        try:
            # Obtener los datos enviados desde el ESP32
            data = json.loads(request.body)
            id_sensor = data.get('id_sensor')
            valor = data.get('valor')
            tipo = data.get('tipo')

            # Verificar que los datos están completos
            if not all([id_sensor, valor, tipo]):
                return JsonResponse({'error': 'Faltan parámetros'}, status=400)
            
            # Verificar si el sensor existe
            try:
                sensor = Sensor.objects.get(id=id_sensor)
            except Sensor.DoesNotExist:
                return JsonResponse({'error': f'Sensor con id {id_sensor} no encontrado'}, status=404)

            # Verificar si el tipo de dato existe
            try:
                tipo_dato = Tipo_dato.objects.get(nombre_tipo_dato=tipo)
            except Tipo_dato.DoesNotExist:
                return JsonResponse({'error': f'Tipo de dato "{tipo}" no encontrado'}, status=404)

            # Intentar guardar en la base de datos
            try:
                # Crear el objeto de datos del sensor
                Datos_sensores.objects.create(
                    sensor=sensor,
                    tipo_dato=tipo_dato,
                    valor=valor
                )
                return JsonResponse({'message': 'Datos insertados correctamente en la base de datos'}, status=200)
            except Exception as db_error:
                # Si falla la base de datos, guardar en el archivo de respaldo
                print(f'Error al guardar en la base de datos: {str(db_error)}')
                
                # Preparar los datos para el respaldo
                datos_respaldo = [{
                    "id_sensor": id_sensor,
                    "nombre_sensor": sensor.nombre_sensor,
                    "tipo": tipo,
                    "valor": valor,
                    "fecha_registro": datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                }]
                
                # Llamar a la función para guardar en el archivo de respaldo
                generar_respaldo(datos_respaldo)
                
                return JsonResponse({'message': 'Datos guardados en archivo de respaldo debido a error en la base de datos'}, status=500)

        except Exception as e:
            return JsonResponse({'error': str(e)}, status=400)
    else:
        return JsonResponse({'error': 'Método no permitido'}, status=405)

def generar_respaldo(datos):
    """Genera un archivo de respaldo en formato tabla en caso de caída de la base de datos."""
    # Obtener la fecha actual para crear el nombre del archivo
    fecha_actual = datetime.now().strftime('%Y-%m-%d')
    archivo_respaldo = os.path.join(BACKUP_DIR, f'datos_{fecha_actual}.txt')

    # Verificar si el archivo ya existe, si no lo crea con el encabezado
    if not os.path.exists(archivo_respaldo):
        with open(archivo_respaldo, 'w') as f:
            # Escribir el encabezado de la tabla
            f.write('| id_sensor | nombre_sensor  | tipo       | valor | fecha_registro         |\n')
            f.write('|-----------|----------------|------------|-------|------------------------|\n')

    # Escribir los datos en el archivo de respaldo
    with open(archivo_respaldo, 'a') as f:
        for dato in datos:
            # Escribir la fila de datos
            f.write(f'| {dato["id_sensor"]:<9} | {dato["nombre_sensor"]:<14} | {dato["tipo"]:<10} | {dato["valor"]:<5} | {dato["fecha_registro"]} |\n')

    print(f'Datos guardados en el archivo de respaldo: {archivo_respaldo}')



------considerar que puede haber problemas de memoria por los archivos de respaldo o los enviados por el esp32
import os
import time
from datetime import datetime, timedelta

# Establecer el número de días para mantener los archivos de respaldo
DAYS_TO_KEEP_BACKUPS = 30

def eliminar_archivos_antiguos():
    """ Elimina los archivos de respaldo que sean más antiguos que el límite de días """
    fecha_limite = datetime.now() - timedelta(days=DAYS_TO_KEEP_BACKUPS)
    directorio_backup = settings.BACKUP_DIR

    # Recorrer los archivos en el directorio de backups
    for filename in os.listdir(directorio_backup):
        archivo_completo = os.path.join(directorio_backup, filename)
        
        # Si el archivo es un archivo de texto de respaldo y es más antiguo que el límite
        if filename.startswith("datos_") and filename.endswith(".txt"):
            # Obtener la fecha del archivo (por ejemplo: datos_2025-01-07.txt)
            fecha_str = filename.split("_")[1].split(".")[0]
            fecha_archivo = datetime.strptime(fecha_str, '%Y-%m-%d')

            if fecha_archivo < fecha_limite:
                # Eliminar archivo si es más antiguo que el límite
                os.remove(archivo_completo)
                print(f"Archivo {archivo_completo} eliminado.")



---------insercion de datos faltantes si se llega a caer la base de datos
# Esta variable global puede ser definida en otro archivo o en la configuración del sistema
# Fecha de la caída de la base de datos, esta fecha debe ser configurada en el momento de la caída
fecha_caida_base_datos = datetime(2025, 1, 7, 14, 30)  # Fecha de la caída (debe ser dinámica)

# Función para revisar los archivos de respaldo y reinsertar los datos en la base de datos

def revisar_datos_perdidos():
    # Obtener la fecha actual
    fecha_actual = datetime.now().strftime('%Y-%m-%d')  # Ejemplo: 2025-01-07
    archivo_respaldo = os.path.join(settings.BACKUP_DIR, f'datos_{fecha_actual}.txt')

    # Verificar si el archivo de respaldo existe
    if os.path.exists(archivo_respaldo):
        with open(archivo_respaldo, 'r') as file:
            lineas = file.readlines()

        # Saltarse la primera línea del archivo (encabezado de la tabla)
        lineas = lineas[2:]

        for linea in lineas:
            # Limpiar la línea y dividirla por el separador '|'
            partes = linea.strip().split('|')

            if len(partes) == 5:
                # Limpiar espacios en blanco extra en cada columna
                id_sensor = partes[1].strip()
                nombre_sensor = partes[2].strip()
                tipo = partes[3].strip()
                valor = partes[4].strip()
                fecha = partes[5].strip()

                # Convertir la fecha del registro a un objeto datetime
                try:
                    fecha_objeto = datetime.strptime(fecha, '%Y-%m-%d %H:%M:%S')

                    # Solo procesar los datos posteriores a la caída de la base de datos
                    if fecha_objeto > fecha_caida_base_datos:
                        try:
                            # Verificar si el sensor y el tipo de dato existen en la base de datos
                            sensor = Sensor.objects.get(id=id_sensor)
                            tipo_dato = Tipo_dato.objects.get(nombre_tipo_dato=tipo)

                            # Crear un nuevo registro en la base de datos
                            Datos_sensores.objects.create(
                                sensor=sensor,
                                tipo_dato=tipo_dato,
                                valor=float(valor),
                                fecha_registro=fecha_objeto  # Usar el objeto datetime para la fecha
                            )

                            print(f'Dato para el sensor {sensor.nombre_sensor} insertado correctamente.')

                        except Sensor.DoesNotExist:
                            print(f"Sensor con id {id_sensor} no encontrado, no se pudo insertar el dato.")
                        except Tipo_dato.DoesNotExist:
                            print(f"Tipo de dato '{tipo}' no encontrado, no se pudo insertar el dato.")
                        except IntegrityError:
                            print(f"Error de integridad al insertar los datos para el sensor {id_sensor} y tipo {tipo}.")
                        except Exception as e:
                            print(f"Error al procesar la línea '{linea}': {e}")
                    else:
                        print(f"El dato con fecha {fecha_objeto} es anterior a la caída de la base de datos, no se insertará.")

                except ValueError as e:
                    print(f"Error al convertir la fecha: {e}")

        print("Revisión de datos perdidos completada.")
    else:
        print(f"No se encontró el archivo de respaldo para la fecha {fecha_actual}.")
